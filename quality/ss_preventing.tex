
 \subsection{Preventing defects}

Defect prevention is a set of methods used to lower the amount of defects coming from one or many of the defect origins. Software defects are originated from different parts of the project. Defect origins can be technical and nontechnical. Some nontechnical origins of defects include requirements and documentation. Technical origins include architecture, design and code. Because defects are originated from multiple sources, there is no single method for covering them all. Most methods are not effective against all sources. Usually there are 1-4 methods used.

Most of the defect prevention methods are not primarily used for preventing defects, but for some other purpose. Preventing the defects is usually a secondary effect and can be sometimes incidental. These methods don't affect structural quality, but the defects of the software. For achieving high total quality of software, defect prevention should be combined with other types of quality methods.

Defect prevention is one of the most difficult topics of software quality. It is hard to measure, improve and prove the economic value. The difficulty originates from the fact that defect prevention is a negative factor that reduces defect potentials. This means that reliable measurement of the efficiency needs multiple points of reference for both using the method and not using it. Despite this, a number of big companies has studied the topic with significant amounts of projects. IBM, for one example, has been studying this topic since its first studies in 1970s. 

% Inspection

\textbf{Formal inspections} were inspected as a one line of research by IBM in the 1970s. The inspections were targeted at requirements, design documents, source code and other deliverables. In a short time they discovered that the defect removal efficiency with formal inspections could reach levels beyond 85\%. At that time that was higher than any form of testing could achieve. In addition, the inspections seemed to affect the accuracy and completeness of the requirements and specification documents, which lead to raising the defect removal efficiency of testing by 5\%. Combining formal inspections with formal testing could raise the efficiency even further to levels as high as 97\%. 

With these improvements in efficiency, the amount of defects in the beginning of testing was reduced significantly. The schedules and budgets of the testing could be cut to half and in some cases even more than half. That lead to about 15\% decrease in combined schedule and cumulative effort compared to similar applications without inspections.

Another result from the studies was that using the formal inspections for a longer time, the project teams unconsciously started avoiding the kind of errors found in the inspections. This meant that the inspections not only removed defects but also prevented them from occurring.

TODO: Jotain nykypäivästä?

% Agile development method p.136 / Agile manifesto?
\textbf{Agile development method} 

% Test driven development TDD book?
\textbf{Test driven development} 

% Automated risk analysis (p. 177-184)
\textbf{Automated risk analysis} 

% Embedded users p.136

\textbf{Embedded users} is an Agile method where one or more user representatives are embedded into the project team. The purpose of the user representative is to provide user requirements and give support in reviewing. The main purpose of this method is to improve the requirements definition. This method is proven to be effective in small software projects with under 100 users and size below 1000 function points. In larger scale applications, over 10000 function points or more than 1000 user, a single representative cannot effectively provide enough requirements. This method can however be scaled up by using multiple user representatives, but like other Agile methods, this is most effective in smaller projects.

% Static analysis p. 185 (Automated p. 267-276)

\textbf{Static analysis} is used to detecting syntactic and structural defects in source code without compiling or executing it. It is used in all sizes of software projects and with every type of applications. The concept is originally from the compilers, which performed syntax checking. Later in the 1970s, the features for detecting defects were improved in a tool called Lint. Static analysis has been further developed over time and nowadays it can comprehensively analyze system-level structure and even security vulnerabilities. Modern tools for static analysis can have defect removal efficiency of over 85\%.

Static analysis tools are based on a library of rules defining the conditions to be examined. Some of the modern commercial tools contain over 1500 rules and allow the users to define their own rules for special conditions. Static analysis is effective in defect removal for using the rules to seek out and eliminate syntactic and structural defects. There are two reasons static analysis is also useful in preventing defects: the rule libraries are also useful for preventing defects and the tools can suggest corrections for defects to the developers. The latter enables the developers to see the effective solutions to the defects while examining the results of the analysis.

